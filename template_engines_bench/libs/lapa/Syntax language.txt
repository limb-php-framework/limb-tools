SyntaxLanguage.txt

               Синтаксис языка Lapa Template ToolKit
Разделение инструкции
Каждая инструкция разделяется переносом строки
        -----------------------------
        <% if $myVar > 0
         $i = 0
         /if
         if $myVar > 1
         $i = 0
         /if %>
        -----------------------------
Закрывающий тег (настраивается пользователем) также подразумевает конец инструкции, поэтому два следующих фрагмента кода эквиваленты:
----------------------------
 <% if $myVar > 0 
       $i = 0
 %>
        
<% if $myVar > 0 %>
<%$i = 0 %>
-----------------------------



Теги могут принимать любой вид. Например { } <% %> <= => <?  ?>
Если параметр $parse_text = 1 (true), возможен разбор текста и поиск переменных в нем
<html><title>$my_var.1;<title>
Данная инструкция начинается с $ и обязательно заканчивается символом ;
Переносы строки и включение в него операторов недопустимы.
мой дядя $my.1.text; правил
$my.1.text;
$my->text; 
Внимание! С версии 0.5.5 610 введена возможность указывать инструкции альтернативным способом.
Пример:
<tpl: foreach from=test item=var>


</tpl: foreach>

Комментарии
Поддерживается только три вида комментариев, 
{*       *} который идет только до конца строки 
или текущего блока, в зависимости от того, что идет перед ними и 
стандартные конструкции. 
<% * это комментарий %>
<% * это комmентарий в стиле Smarty * 

%>
<% $i // это комmентарий %>
Типы данных
Строки
Строка может быть в кавычках или в двойных кавычках.
<% $string  = 'Это строка'
$string2 = "Это строка" %>
В отличие от других шаблонизаторов одинарные и двойные кавычки обрабатываются как простые строки
<% $string  = 'Это \' строка \' '  %>
Внутреннее представление строк будет преобразовано в php коде к строке с одинарными кавычками
        
Числа
Числа могут быть только целыми.
Во внутренем представлении строки и числа приравнены к одному типу: строка
Если вам нужно использовать дробные и т.п. числа, подготавливайте их заранее в php, или
объявляйте в строковом варианте '897.989'
Также можно использовать 077 или 0x23
    
Массивы. Анологично PHP
set $i = array('one'=>Ю, 'привет', 2=>'two', array(1, $var->yt(1)) ) # и так далее        
    
Логические 
TRUE FALSE ON/YES OFF/NO
Заключать в кавычки не стоит, иначе они будут строками
        
Обьекты и любые другие типы вы можете присваивать из других 
переменных или функций.   
      
Все остальные типы обьявлять в коде шаблонов нельзя.
<% $object  = new $Class %> недопустимо
set $object = MyClass::Factory() %> допустимо 
     
Переменные
Локальные (<% set $$my_var  = 1 %>), видимость  только в текущем шаблоне. 
Глобальные (<% set $my_var  = 1 %>)  и имеют область видимости всех шаблонов, Конфигурационные (<% Lapa.config.mysection.my_var %>) или (#my_var#)  
#section.myvar
      
5) Константы.
Вызывать константы можно через классы.<% myClass::MyConst %>
Можно использовать переменную $Lapa.const.MYCONST
Выражения - аналогично PHP, осуществляется проверка допустимости использования
<% set $b = $a = 5  %> <% set $b-- = $a++ = 5  %>
       
Операторы - аналогично PHP кроме проверки принадлежности к классу
Oператор конкатенации (' .. '), который возвращает объединение левого и правого аргумента
<%  set $b = $a .. 
$r %>
Директивы. Скобки в выражениях не требуются
IF, ELSEIF,  ELSE IF ELSE, /IF - регистронезависимы
<% IF $arr_var.1 == 1 %>
Текст
<% ELSEIF $arr_var.1 == 2 %>
Текст
<% ELSE %>
Текст
<% /IF %>
SWITCH CASE CASEELSE /SWITCH - регистронезависимы
данная функция вынсеена в plugin'ы компилятора
<% SWITCH $arr_var.1 
CASE 2, 3, 4, 5 %> Текст
<% CASE 'op' %>
Текст
<% CASEELSE %>
Текст
<% /SWITH %>
Как видите можно указывать ряд значений через запятую
Команду BREAK явно указывать не нужно, она формируется самостоятельно
Для продвинутых пользователей break можно отключить
{directive break = off }
<?php
switch ($_var['arr_var'][1]):
case 1: case 2:  case 3:  case 4:  case 5: ?>
            Текст
            <?php break;
            case 'op':
            ?>
            Текст
            <?php break;
            default: ?>
            Текст
            <?php 
        endswith;?>

LOOP 
from - переменная, содержащая массив, обьект, или число (можно указывать просто 10).
value - переменная - итератор 
step - шаг
start - итератор = start
 по умолчанию старт у массива и объекта начинается с 0
  у чисел с 1  
{loop from = $testobj value=$i}
{$i}
{/loop}
{loop from =10 value=$i}
 {$i}
 {/loop}
FOREACH FOREACHELSE /FOREACH - регистронезависимы
имеет 6 регистронезависимых параметра
NAME - имя цикла для доступа к служебным данным, количество итераций и т.п.
FROM - массив данных (может быть обьектом)
KEY  - переменная с получаемым значением ключа
ITEM - переменная с получаемым значением
MAX  - количество итераций для принудительного выхода (по умолчанию не установлено)
COPY - по умолчанию TRUE, работает на копии массива.
Можно передавать в KEY и ITEM локальные переменные
<% FOREACH NAME = 'test' FROM=$arr_var KEY=$key ITEM=$item MAX = 100 %>
<% $key %>::<% $item  
FOREACHELSE %>
Данных нет
<% /FOREACH %>
<% FOREACH NAME = 'test' FROM=$arr_var KEY=$$key ITEM=$$item MAX = 100 %>
<% $$key %>::<% $$item  
FOREACHELSE %>
Данных нет
<% /FOREACH %>
        
WHILE WHILEELSE /WHILE - регистронезависимы имеет 1 параметр
 MAX  - максимальное количество итераций, по умолчанию не контролируется
<% WHILE NAME = 'test2' MAX = 100 $myvar > 100 %>
<% $myvar %> 
<% WHILEELSE %>
Данных нет
<% /WHILE %>
CONTINUE, BREAK - регистронезависимы
Могут использоватся в пределах цикла и switch соответственно. Можно указывать уровень выхода
continue 2 break 3

INSERT_FILE - регистронезависимы
Используется для вставки ресурсов в исходный шаблон, имеет 2 регистронезависимых параметра
FILE - путь к шаблону, реализация через ресурсы
<% INSERT_FILE FILE = 'template/template.php' %>

INCLUDE 
FILE - путь к шаблону
ASSIGN - имя переменной, можно указать как имя, так и переменную (и локальную тоже)
include file='file.tpl' assign=$var

assign
CALL, SET ?
Используется для вызова функций и методов без вывода
Выражения без set или ? вызовут ошибку разбора
<%
        set $var = 1
        ?$var = 1
        CALL $var->buffer('start')
        .........
        ? $var->buffer('stop')
        %>
                <%
        CALL myClass::buffer('start')
        .........
        CALL myClass::buffer('stop')
        %>
    
LITERAL /LITERAL
        Все что заключено в эти теги считается текстом и не обрабатывается.
Функции 
Функции вызываются, так же как и php. Вероятно, будет массив с возможными функциями, остальные вызовут ошибку разбора.
Объекты
Поведение обьектов аналогично php. Можно вызывать методы, в некоторых контекстах
вызывать методы нельзя (обсуждается)   
Статические методы тоже можно вызвать. myobject::myMethod(1, 3)
Вывод
    Переменные, результат выполнения функций автоматически выводятся.
    <%$i = 1 > 0 %>
    
Если требуется вызвать метод или функцию используйте директиву CALL

Модификаторы

Все знакомы, и применяются таким образом.
    $foo->method()|   mymod:   100    :     'строковой параметр': "тоже параметр"
    $foo->method()|mymod:100 : 'строковой параметр': "тоже параметр"|mydef:12:111
    как вы заметили, пробелы не влияют почти ни на что, или вообще ни на что
    
    встроенные модификаторы 
    $var|isset:  'yes', аналог php
    $var|default:'yes'
    
